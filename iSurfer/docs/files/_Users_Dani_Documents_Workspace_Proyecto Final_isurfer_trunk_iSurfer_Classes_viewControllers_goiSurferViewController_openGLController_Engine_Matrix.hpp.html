<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>&#x2F;Users&#x2F;Dani&#x2F;Documents&#x2F;Workspace&#x2F;Proyecto Final&#x2F;isurfer&#x2F;trunk&#x2F;iSurfer&#x2F;Classes&#x2F;viewControllers&#x2F;goiSurferViewController&#x2F;openGLController&#x2F;Engine&#x2F;Matrix.hpp - iSurfer</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src=".&#x2F;..&#x2F;resources&#x2F;images&#x2F;Imaginary_lemon_mini.jpg" title="iSurfer"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 3.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ApplicationEngine.html">ApplicationEngine</a></li>
            
                <li><a href="..&#x2F;classes/Compiler.html">Compiler</a></li>
            
                <li><a href="..&#x2F;classes/Error.html">Error</a></li>
            
                <li><a href="..&#x2F;classes/exception.html">exception</a></li>
            
                <li><a href="..&#x2F;classes/expressionT.html">expressionT</a></li>
            
                <li><a href="..&#x2F;classes/Fragment_Shader.html">Fragment_Shader</a></li>
            
                <li><a href="..&#x2F;classes/genlib.html">genlib</a></li>
            
                <li><a href="..&#x2F;classes/Matrix.html">Matrix</a></li>
            
                <li><a href="..&#x2F;classes/ParametricEquations.html">ParametricEquations</a></li>
            
                <li><a href="..&#x2F;classes/ParametricSurface.html">ParametricSurface</a></li>
            
                <li><a href="..&#x2F;classes/parser.html">parser</a></li>
            
                <li><a href="..&#x2F;classes/programData.html">programData</a></li>
            
                <li><a href="..&#x2F;classes/QuaternionT.html">QuaternionT</a></li>
            
                <li><a href="..&#x2F;classes/ScannerADT.html">ScannerADT</a></li>
            
                <li><a href="..&#x2F;classes/simpio.html">simpio</a></li>
            
                <li><a href="..&#x2F;classes/strlib.html">strlib</a></li>
            
                <li><a href="..&#x2F;classes/surfaceRender.html">surfaceRender</a></li>
            
                <li><a href="..&#x2F;classes/Vector.html">Vector</a></li>
            
                <li><a href="..&#x2F;classes/Vertex_Shader.html">Vertex_Shader</a></li>
            
                <li><a href="..&#x2F;classes/Wire_Fragment_Shader.html">Wire_Fragment_Shader</a></li>
            
                <li><a href="..&#x2F;classes/Wire_Vertex_Shader.html">Wire_Vertex_Shader</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Engine.html">Engine</a></li>
            
                <li><a href="..&#x2F;modules/OpenGL.html">OpenGL</a></li>
            
                <li><a href="..&#x2F;modules/Parser.html">Parser</a></li>
            
                <li><a href="..&#x2F;modules/Surface.html">Surface</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: &#x2F;Users&#x2F;Dani&#x2F;Documents&#x2F;Workspace&#x2F;Proyecto Final&#x2F;isurfer&#x2F;trunk&#x2F;iSurfer&#x2F;Classes&#x2F;viewControllers&#x2F;goiSurferViewController&#x2F;openGLController&#x2F;Engine&#x2F;Matrix.hpp</h1>

<div class="file">
    <pre class="code prettyprint linenums">
#pragma once
#include &quot;Vector.hpp&quot;
#include &quot;stdio.h&quot;

&#x2F;**
 * File: Matrix.hpp
 * Version: 1.0
 * @module Engine
 *&#x2F;

&#x2F;** 
 * Last modified on February 13 2012 by dazar
 * -----------------------------------------------------
 * This interface provides access to a Matrix library. Matrix2, Matrix3, Matrix4.
 * It is based on the book &quot;iPhone 3D Programming&quot; with some added functionality like matrix inverse.
 * 
 * @class Matrix
 *&#x2F;


typedef float Matrix4x4[16];

template &lt;typename T&gt;
struct Matrix2 {
    Matrix2()
    {
        x.x = 1; x.y = 0;
        y.x = 0; y.y = 1;
    }
    Matrix2(const T* m)
    {
        x.x = m[0]; x.y = m[1];
        y.x = m[2]; y.y = m[3];
    }
    vec2 x;
    vec2 y;
};

template &lt;typename T&gt;
struct Matrix3 {
    Matrix3()
    {
        x.x = 1; x.y = 0; x.z = 0;
        y.x = 0; y.y = 1; y.z = 0;
        z.x = 0; z.y = 0; z.z = 1;
    }
    Matrix3(const T* m)
    {
        x.x = m[0]; x.y = m[1]; x.z = m[2];
        y.x = m[3]; y.y = m[4]; y.z = m[5];
        z.x = m[6]; z.y = m[7]; z.z = m[8];
    }
    Matrix3 Transposed() const
    {
        Matrix3 m;
        m.x.x = x.x; m.x.y = y.x; m.x.z = z.x;
        m.y.x = x.y; m.y.y = y.y; m.y.z = z.y;
        m.z.x = x.z; m.z.y = y.z; m.z.z = z.z;
        return m;
    }
    const T* Pointer() const
    {
        return &amp;x.x;
    }
    vec3 x;
    vec3 y;
    vec3 z;
};

template &lt;typename T&gt;
struct Matrix4 {
    Matrix4()
    {
        x.x = 1; x.y = 0; x.z = 0; x.w = 0;
        y.x = 0; y.y = 1; y.z = 0; y.w = 0;
        z.x = 0; z.y = 0; z.z = 1; z.w = 0;
        w.x = 0; w.y = 0; w.z = 0; w.w = 1;
    }
    Matrix4(const Matrix3&lt;T&gt;&amp; m)
    {
        x.x = m.x.x; x.y = m.x.y; x.z = m.x.z; x.w = 0;
        y.x = m.y.x; y.y = m.y.y; y.z = m.y.z; y.w = 0;
        z.x = m.z.x; z.y = m.z.y; z.z = m.z.z; z.w = 0;
        w.x = 0; w.y = 0; w.z = 0; w.w = 1;
    }
    Matrix4(const T* m)
    {
        x.x = m[0];  x.y = m[1];  x.z = m[2];  x.w = m[3];
        y.x = m[4];  y.y = m[5];  y.z = m[6];  y.w = m[7];
        z.x = m[8];  z.y = m[9];  z.z = m[10]; z.w = m[11];
        w.x = m[12]; w.y = m[13]; w.z = m[14]; w.w = m[15];
    }
    Matrix4 operator * (const Matrix4&amp; b) const
    {
        Matrix4 m;
        m.x.x = x.x * b.x.x + x.y * b.y.x + x.z * b.z.x + x.w * b.w.x;
        m.x.y = x.x * b.x.y + x.y * b.y.y + x.z * b.z.y + x.w * b.w.y;
        m.x.z = x.x * b.x.z + x.y * b.y.z + x.z * b.z.z + x.w * b.w.z;
        m.x.w = x.x * b.x.w + x.y * b.y.w + x.z * b.z.w + x.w * b.w.w;
        m.y.x = y.x * b.x.x + y.y * b.y.x + y.z * b.z.x + y.w * b.w.x;
        m.y.y = y.x * b.x.y + y.y * b.y.y + y.z * b.z.y + y.w * b.w.y;
        m.y.z = y.x * b.x.z + y.y * b.y.z + y.z * b.z.z + y.w * b.w.z;
        m.y.w = y.x * b.x.w + y.y * b.y.w + y.z * b.z.w + y.w * b.w.w;
        m.z.x = z.x * b.x.x + z.y * b.y.x + z.z * b.z.x + z.w * b.w.x;
        m.z.y = z.x * b.x.y + z.y * b.y.y + z.z * b.z.y + z.w * b.w.y;
        m.z.z = z.x * b.x.z + z.y * b.y.z + z.z * b.z.z + z.w * b.w.z;
        m.z.w = z.x * b.x.w + z.y * b.y.w + z.z * b.z.w + z.w * b.w.w;
        m.w.x = w.x * b.x.x + w.y * b.y.x + w.z * b.z.x + w.w * b.w.x;
        m.w.y = w.x * b.x.y + w.y * b.y.y + w.z * b.z.y + w.w * b.w.y;
        m.w.z = w.x * b.x.z + w.y * b.y.z + w.z * b.z.z + w.w * b.w.z;
        m.w.w = w.x * b.x.w + w.y * b.y.w + w.z * b.z.w + w.w * b.w.w;
        return m;
    }
    
    
    static Matrix4&lt;T&gt; Ortho(T left, T right, T bottom, T top, T near, T far)
    {
        T a = 2.0f &#x2F; (right - left);
        T b = 2.0f &#x2F; (top - bottom);
        T c = -2.0f &#x2F; (far - near);
        T tx = -(right + left) &#x2F; (right - left);
        T ty = -(top + bottom) &#x2F; (top - bottom);
        T tz = -(far + near) &#x2F; (far - near);
        Matrix4 m;
        m.x.x = a; m.x.y = 0; m.x.z = 0; m.w.x = tx;
        m.y.x = 0; m.y.y = b; m.y.z = 0; m.w.y = ty;
        m.z.x = 0; m.z.y = 0; m.z.z = c; m.w.z = tz;
        m.x.w = 0; m.y.w = 0; m.z.w = 0; m.w.w = 1.0;
        return m;
    }
    
    static Matrix4&lt;T&gt; LookAt(vec3 eye, vec3 target, vec3 up)
    {
        vec3 zaxis = (target - eye).Normalized();    &#x2F;&#x2F; The &quot;look-at&quot; vector.

        vec3  xaxis = (up.Cross(zaxis)).Normalized();&#x2F;&#x2F; The &quot;right&quot; vector.
        vec3  yaxis = zaxis.Cross(xaxis);     &#x2F;&#x2F; The &quot;up&quot; vector.
        
        
        Matrix4 m, translation;
        m.x.x = xaxis.x; m.x.y = yaxis.x; m.x.z = zaxis.x; m.w.x = 0;
        m.y.x = xaxis.y; m.y.y = yaxis.y; m.y.z = zaxis.y; m.w.y = 0;
        m.z.x = xaxis.z; m.z.y = yaxis.z; m.z.z = zaxis.z; m.w.z = 0;
        m.x.w = 0;       m.y.w = 0;       m.z.w = 0;       m.w.w = 1;

           
        translation = Translate(-eye.x, -eye.y,-eye.z);
  
            &#x2F;&#x2F; Create a 4x4 translation matrix by negating the eye position.
            &#x2F;&#x2F; Combine the orientation and translation to compute the view matrix
        &#x2F;&#x2F;http:&#x2F;&#x2F;3dgep.com&#x2F;?p=1700
        return ( translation * m );
    

    }
    
    Matrix4&amp; operator *= (const Matrix4&amp; b)
    {
        Matrix4 m = *this * b;
        return (*this = m);
    }
    Matrix4 Transposed() const
    {
        Matrix4 m;
        m.x.x = x.x; m.x.y = y.x; m.x.z = z.x; m.x.w = w.x;
        m.y.x = x.y; m.y.y = y.y; m.y.z = z.y; m.y.w = w.y;
        m.z.x = x.z; m.z.y = y.z; m.z.z = z.z; m.z.w = w.z;
        m.w.x = x.w; m.w.y = y.w; m.w.z = z.w; m.w.w = w.w;
        return m;
    }
    Matrix3&lt;T&gt; ToMat3() const
    {
        Matrix3&lt;T&gt; m;
        m.x.x = x.x; m.y.x = y.x; m.z.x = z.x;
        m.x.y = x.y; m.y.y = y.y; m.z.y = z.y;
        m.x.z = x.z; m.y.z = y.z; m.z.z = z.z;
        return m;
    }
    const T* Pointer() const
    {
        return &amp;x.x;
    }
    static Matrix4&lt;T&gt; Identity()
    {
        return Matrix4();
    }
    static Matrix4&lt;T&gt; Translate(T x, T y, T z)
    {
        Matrix4 m;
        m.x.x = 1; m.x.y = 0; m.x.z = 0; m.x.w = 0;
        m.y.x = 0; m.y.y = 1; m.y.z = 0; m.y.w = 0;
        m.z.x = 0; m.z.y = 0; m.z.z = 1; m.z.w = 0;
        m.w.x = x; m.w.y = y; m.w.z = z; m.w.w = 1;
        return m;
    }
    static Matrix4&lt;T&gt; Scale(T s)
    {
        Matrix4 m;
        m.x.x = s; m.x.y = 0; m.x.z = 0; m.x.w = 0;
        m.y.x = 0; m.y.y = s; m.y.z = 0; m.y.w = 0;
        m.z.x = 0; m.z.y = 0; m.z.z = s; m.z.w = 0;
        m.w.x = 0; m.w.y = 0; m.w.z = 0; m.w.w = 1;
        return m;
    }
    
    static Matrix4&lt;T&gt; Scale(T x, T y, T z)
    {
        Matrix4 m;
        m.x.x = x; m.x.y = 0; m.x.z = 0; m.x.w = 0;
        m.y.x = 0; m.y.y = y; m.y.z = 0; m.y.w = 0;
        m.z.x = 0; m.z.y = 0; m.z.z = z; m.z.w = 0;
        m.w.x = 0; m.w.y = 0; m.w.z = 0; m.w.w = 1;
        return m;
    }

    static Matrix4&lt;T&gt; Rotate(T degrees)
    {
        T radians = degrees * 3.14159f &#x2F; 180.0f;
        T s = std::sin(radians);
        T c = std::cos(radians);
        
        Matrix4 m;
        m.x.x =  c; m.x.y = s; m.x.z = 0; m.x.w = 0;
        m.y.x = -s; m.y.y = c; m.y.z = 0; m.y.w = 0;
        m.z.x =  0; m.z.y = 0; m.z.z = 1; m.z.w = 0;
        m.w.x =  0; m.w.y = 0; m.w.z = 0; m.w.w = 1;
        return m;
    }
    
    static Matrix4&lt;T&gt; Perspective(float fovy, float aspect, float zNear, float zFar)
    {
        float xmin, xmax, ymin, ymax;
        ymax = zNear * tan(fovy * M_PI &#x2F; 360.0);
        ymin = -ymax;
        xmin = ymin * aspect;
        xmax = ymax * aspect;
        return Frustum(xmin, xmax, ymin, ymax, zNear, zFar);
    }

    
    static Matrix4&lt;T&gt; Frustum(T left, T right, T bottom, T top, T near, T far)
    {
        T a = 2 * near &#x2F; (right - left);
        T b = 2 * near &#x2F; (top - bottom);
        T c = (right + left) &#x2F; (right - left);
        T d = (top + bottom) &#x2F; (top - bottom);
        T e = - (far + near) &#x2F; (far - near);
        T f = -2 * far * near &#x2F; (far - near);
        Matrix4 m;
        m.x.x = a; m.x.y = 0; m.x.z = 0; m.x.w = 0;
        m.y.x = 0; m.y.y = b; m.y.z = 0; m.y.w = 0;
        m.z.x = c; m.z.y = d; m.z.z = e; m.z.w = -1;
        m.w.x = 0; m.w.y = 0; m.w.z = f; m.w.w = 1;
        return m;
    }
    static Matrix4&lt;T&gt; fromCATransform3D(vec4 x, vec4 y, vec4 z , vec4 w)
    {
        Matrix4 m;
        m.x = x;
        m.y = y;
        m.z = z;
        m.w = w;
        return m;
    }

    void toMatrix4x4(Matrix4x4 result) 
    {
#define M(row,col)  result[col*4+row]
        M(0,0) = x.x;     M(0,1) = y.x;  M(0,2) = z.x;      M(0,3) = w.x;
        M(1,0) = x.y;     M(1,1) = y.y;  M(1,2) = z.y;      M(1,3) = w.y;
        M(2,0) = x.z;     M(2,1) = y.z;  M(2,2) = z.z;      M(2,3) = w.z;
        M(3,0) = x.w;     M(3,1) = y.w;  M(3,2) = z.w;      M(3,3) = w.w;
#undef M
    }
    
     Matrix4&lt;T&gt; invert_matrix() 
    {
        Matrix4x4 aux, result;
        toMatrix4x4(aux);

        invert_matrix(aux, result);
    
        return Matrix4(result); 
    }
    
    
    
    
#define MAT(m,r,c) (m)[(c)*4+(r)]
#define SWAP_ROWS(a, b) { float *_tmp = a; (a)=(b); (b)=_tmp; }
#define FABSF(x)   ((float) fabs(x))
    bool invert_matrix( const Matrix4x4 m, Matrix4x4 result  )
    {
        float *out = result;
        float wtmp[4][8];
        float m0, m1, m2, m3, s;
        float *r0, *r1, *r2, *r3;
        
        r0 = wtmp[0], r1 = wtmp[1], r2 = wtmp[2], r3 = wtmp[3];
        
        r0[0] = MAT(m,0,0), r0[1] = MAT(m,0,1),
        r0[2] = MAT(m,0,2), r0[3] = MAT(m,0,3),
        r0[4] = 1.0, r0[5] = r0[6] = r0[7] = 0.0,
        
        r1[0] = MAT(m,1,0), r1[1] = MAT(m,1,1),
        r1[2] = MAT(m,1,2), r1[3] = MAT(m,1,3),
        r1[5] = 1.0, r1[4] = r1[6] = r1[7] = 0.0,
        
        r2[0] = MAT(m,2,0), r2[1] = MAT(m,2,1),
        r2[2] = MAT(m,2,2), r2[3] = MAT(m,2,3),
        r2[6] = 1.0, r2[4] = r2[5] = r2[7] = 0.0,
        
        r3[0] = MAT(m,3,0), r3[1] = MAT(m,3,1),
        r3[2] = MAT(m,3,2), r3[3] = MAT(m,3,3),
        r3[7] = 1.0, r3[4] = r3[5] = r3[6] = 0.0;
        
        &#x2F;* choose pivot - or die *&#x2F;
        if (FABSF(r3[0])&gt;FABSF(r2[0])) SWAP_ROWS(r3, r2);
        if (FABSF(r2[0])&gt;FABSF(r1[0])) SWAP_ROWS(r2, r1);
        if (FABSF(r1[0])&gt;FABSF(r0[0])) SWAP_ROWS(r1, r0);
        if (0.0 == r0[0])  return false;
        
        &#x2F;* eliminate first variable     *&#x2F;
        m1 = r1[0]&#x2F;r0[0]; m2 = r2[0]&#x2F;r0[0]; m3 = r3[0]&#x2F;r0[0];
        s = r0[1]; r1[1] -= m1 * s; r2[1] -= m2 * s; r3[1] -= m3 * s;
        s = r0[2]; r1[2] -= m1 * s; r2[2] -= m2 * s; r3[2] -= m3 * s;
        s = r0[3]; r1[3] -= m1 * s; r2[3] -= m2 * s; r3[3] -= m3 * s;
        s = r0[4];
        if (s != 0.0) { r1[4] -= m1 * s; r2[4] -= m2 * s; r3[4] -= m3 * s; }
        s = r0[5];
        if (s != 0.0) { r1[5] -= m1 * s; r2[5] -= m2 * s; r3[5] -= m3 * s; }
        s = r0[6];
        if (s != 0.0) { r1[6] -= m1 * s; r2[6] -= m2 * s; r3[6] -= m3 * s; }
        s = r0[7];
        if (s != 0.0) { r1[7] -= m1 * s; r2[7] -= m2 * s; r3[7] -= m3 * s; }
        
        &#x2F;* choose pivot - or die *&#x2F;
        if (FABSF(r3[1])&gt;FABSF(r2[1])) SWAP_ROWS(r3, r2);
        if (FABSF(r2[1])&gt;FABSF(r1[1])) SWAP_ROWS(r2, r1);
        if (0.0 == r1[1])  return false;
        
        &#x2F;* eliminate second variable *&#x2F;
        m2 = r2[1]&#x2F;r1[1]; m3 = r3[1]&#x2F;r1[1];
        r2[2] -= m2 * r1[2]; r3[2] -= m3 * r1[2];
        r2[3] -= m2 * r1[3]; r3[3] -= m3 * r1[3];
        s = r1[4]; if (0.0 != s) { r2[4] -= m2 * s; r3[4] -= m3 * s; }
        s = r1[5]; if (0.0 != s) { r2[5] -= m2 * s; r3[5] -= m3 * s; }
        s = r1[6]; if (0.0 != s) { r2[6] -= m2 * s; r3[6] -= m3 * s; }
        s = r1[7]; if (0.0 != s) { r2[7] -= m2 * s; r3[7] -= m3 * s; }
        
        &#x2F;* choose pivot - or die *&#x2F;
        if (FABSF(r3[2])&gt;FABSF(r2[2])) SWAP_ROWS(r3, r2);
        if (0.0 == r2[2])  return false;
        
        &#x2F;* eliminate third variable *&#x2F;
        m3 = r3[2]&#x2F;r2[2];
        r3[3] -= m3 * r2[3], r3[4] -= m3 * r2[4],
        r3[5] -= m3 * r2[5], r3[6] -= m3 * r2[6],
        r3[7] -= m3 * r2[7];
        
        &#x2F;* last check *&#x2F;
        if (0.0 == r3[3]) return false;
        
        s = 1.0F&#x2F;r3[3];             &#x2F;* now back substitute row 3 *&#x2F;
        r3[4] *= s; r3[5] *= s; r3[6] *= s; r3[7] *= s;
        
        m2 = r2[3];                 &#x2F;* now back substitute row 2 *&#x2F;
        s  = 1.0F&#x2F;r2[2];
        r2[4] = s * (r2[4] - r3[4] * m2), r2[5] = s * (r2[5] - r3[5] * m2),
        r2[6] = s * (r2[6] - r3[6] * m2), r2[7] = s * (r2[7] - r3[7] * m2);
        m1 = r1[3];
        r1[4] -= r3[4] * m1, r1[5] -= r3[5] * m1,
        r1[6] -= r3[6] * m1, r1[7] -= r3[7] * m1;
        m0 = r0[3];
        r0[4] -= r3[4] * m0, r0[5] -= r3[5] * m0,
        r0[6] -= r3[6] * m0, r0[7] -= r3[7] * m0;
        
        m1 = r1[2];                 &#x2F;* now back substitute row 1 *&#x2F;
        s  = 1.0F&#x2F;r1[1];
        r1[4] = s * (r1[4] - r2[4] * m1), r1[5] = s * (r1[5] - r2[5] * m1),
        r1[6] = s * (r1[6] - r2[6] * m1), r1[7] = s * (r1[7] - r2[7] * m1);
        m0 = r0[2];
        r0[4] -= r2[4] * m0, r0[5] -= r2[5] * m0,
        r0[6] -= r2[6] * m0, r0[7] -= r2[7] * m0;
        
        m0 = r0[1];                 &#x2F;* now back substitute row 0 *&#x2F;
        s  = 1.0F&#x2F;r0[0];
        r0[4] = s * (r0[4] - r1[4] * m0), r0[5] = s * (r0[5] - r1[5] * m0),
        r0[6] = s * (r0[6] - r1[6] * m0), r0[7] = s * (r0[7] - r1[7] * m0);
        
        MAT(out,0,0) = r0[4]; MAT(out,0,1) = r0[5],
        MAT(out,0,2) = r0[6]; MAT(out,0,3) = r0[7],
        MAT(out,1,0) = r1[4]; MAT(out,1,1) = r1[5],
        MAT(out,1,2) = r1[6]; MAT(out,1,3) = r1[7],
        MAT(out,2,0) = r2[4]; MAT(out,2,1) = r2[5],
        MAT(out,2,2) = r2[6]; MAT(out,2,3) = r2[7],
        MAT(out,3,0) = r3[4]; MAT(out,3,1) = r3[5],
        MAT(out,3,2) = r3[6]; MAT(out,3,3) = r3[7];
        
        return true;
    }

    
    vec4 x;
    vec4 y;
    vec4 z;
    vec4 w;
};

typedef Matrix2&lt;float&gt; mat2;
typedef Matrix3&lt;float&gt; mat3;
typedef Matrix4&lt;float&gt; mat4;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
